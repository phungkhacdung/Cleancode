/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
*******************************************************************************
 *				 _ _                                             _ _
				|   |                                           (_ _)
				|   |        _ _     _ _   _ _ _ _ _ _ _ _ _ _   _ _
				|   |       |   |   |   | |    _ _     _ _    | |   |
				|   |       |   |   |   | |   |   |   |   |   | |   |
				|   |       |   |   |   | |   |   |   |   |   | |   |
				|   |_ _ _  |   |_ _|   | |   |   |   |   |   | |   |
				|_ _ _ _ _| |_ _ _ _ _ _| |_ _|   |_ _|   |_ _| |_ _|
								(C)2022 Lumi
 * Copyright (c) 2022
 * Lumi, JSC.
 * All Rights Reserved
 *
 * File name: main.h
 *
 * Description:
 *
 *
 * Last Changed By:  $Author: dungpk $
 * Revision:         $Revision: $
 * Last Changed:     $Date: $June 4, 2022
 *
 * Code sample:
 ******************************************************************************/
/******************************************************************************/
/*                              INCLUDE FILES                                 */
/******************************************************************************/

#include <stdint.h>
#include "stm32f401re_rcc.h"
#include "stm32f401re_gpio.h"
#include "stm32f401re_adc.h"
#include "stm32f401re_usart.h"
#include "timer.h"
#include "stm32f401re_tim.h"
#include "kalman_filter.h"

/******************************************************************************/
/*                     PRIVATE TYPES and DEFINITIONS                         */
/******************************************************************************/

/******************************************************************************/
/*                     EXPORTED TYPES and DEFINITIONS                         */
/******************************************************************************/

TIME_abl_process						100

#define Tim_Period						8399 //Period cho timer 1 để tạo tần số 10khz.

#define ADC_GPIO_PORT					GPIOC // Khai báo chân sử dụng ADC1
#define ADC_GPIO_PIN					GPIO_Pin_5 // Pin sử dụng ADC1
#define ADCx_SENSOR						ADC1 // ADC cần sử dụng
#define	ADCx_CLK						RCC_APB2Periph_ADC1 // Clock cần cấp ngoại vi

/******************************************************************************/
/*                              PRIVATE DATA                                  */
/******************************************************************************/

/******************************************************************************/
/*                              EXPORTED DATA                                 */
/******************************************************************************/

uint16_t g_wLightValue = 0; // Biến lưu giá trị của ánh sáng

static uint32_t g_dwTimeCurrent = 0,g_dwTimeInitial = 0; // Khởi tạo biến đếm thời gian
static uint32_t g_dwTimeTotal = 0;

/******************************************************************************/
/*                            PRIVATE FUNCTIONS                               */
/******************************************************************************/

/******************************************************************************/
/*                            EXPORTED FUNCTIONS                              */
/******************************************************************************/

static void_t light_sensor_adc_init(void_t);  // Hàm khởi tạo ADC
static void_t led_control_timer_oc_init(void_t); // Hàm khởi tạo timer điều khiển led
static u16_t light_sensor_adc_polling_read(void_t); // Hàm đọc giá trị từ cảm biến ánh sáng
static void_t usart_init(void_t); // Hàm khởi tạo USART để test giá trị nhận được từ cảm biến
static void_t multi_sensor_scan(void_t); // Hàm cập nhật thời gian cần  nhận dữ liệu
static void_t cover_light(void_t); // Hàm gửi dữ liệu ánh sáng qua USART2
static void_t led_control_timer_oc_set_pwm(u16_t wDutyCycle); // Hàm điều khiển led theo ánh sáng
static u8_t abl_step_brightness(u16_t wLightBrightness); // Hàm quy đổi độ sáng sang tần số tương ứng của led
static u16_t light_filter(u16_t wLightFilter); // Hàm xử lý ánh sáng qua bộ lọc kanmal
static void_t abl_process(void_t); // Hàm xử lý gồm những hàm con đã nêu ở trên
static void_t application_init(void_t);
static void_t delay_ms(uint32_t dwMilisectic);

/******************************************************************************/


int main(void_t)
{
	application_init();
	
	while(1)
	{
		multi_sensor_scan(); // Hàm cập nhật thời gian mỗi lần đo và thay đổi độ sáng của đèn theo giá trị nhận được từ cảm biến ánh sáng

	}
}

/*
 * @func   application_init
 * @brief  Initialize application
 * @param  None
 * @retval None
 */
static void_t application_init(void_t)
{
	SystemCoreClockUpdate(); // Cap xung clock
	TimerInit(); // Khởi tạo timer tính toán thời gian
	light_sensor_adc_init(); // Hàm khởi tạo ADC
	led_control_timer_oc_init(); // Hàm khởi tạo timer chế độ output compare
	usart_init(); // Hàm khởi tạo USART để test
	KalmanFilterInit(2,2,0.001); // Hàm khởi tạo bộ lọc kanmal với tham số là _err_measure,err_estimate và _q
}

/*
 * @func   light_sensor_adc_init
 * @brief  Initialize adc
 * @param  None
 * @retval None
 */
static void_t light_sensor_adc_init(void_t)
{
	GPIO_InitTypeDef 		GPIO_InitStructure; // Khoi tao struct GPIO
	ADC_InitTypeDef			ADC_InitStructure; // Khoi tao struct ADC_Init
	ADC_CommonInitTypeDef	ADC_CommnonInitStructure; // Khoi tao struct ADC_common

	//
	RCC_APB2PeriphClockCmd(ADCx_CLK,ENABLE); // Cap xung cho ngoai vi ADC


	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE); // Cap xung cho PORTC

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN; // Chế độ GPIO mode ANALOG
	GPIO_InitStructure.GPIO_Pin = ADC_GPIO_PIN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; // Chế độ nopull

	GPIO_Init(ADC_GPIO_PORT,&GPIO_InitStructure); // KHởi tao GPIO
	//
	ADC_DeInit(); // Cấu hính lại ADC
	//
	ADC_CommnonInitStructure.ADC_Mode = ADC_Mode_Independent; //Chọn chế độ cho ADC là ADC_Mode_Independent.
	ADC_CommnonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2; //Chọn hệ số chia tần số là 1.
	ADC_CommnonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled; //Không sử dụng DMA.
	ADC_CommnonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;//Chọn thời gian giữa 2 lần chuyển đổi là 5Cycles.
	ADC_CommonInit(&ADC_CommnonInitStructure);

	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b; //Chọn số bit chuyển đổi là 12 bit.
	ADC_InitStructure.ADC_ScanConvMode = DISABLE; //Không cho phép sử dụng chuyển đổi không liên tục.
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; //Cho phép sử dụng chuyển đổi liên tục.
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//Cho phép ghi dữ liệu từ bên phải.
	ADC_InitStructure.ADC_NbrOfConversion = 1;//Chọn số kênh sử dụng là 1

	ADC_Init(ADC1,&ADC_InitStructure); //Sử dụng hàm ADC_Init với tham số là bộ ADC đang sử dụng và biến
	//dữ liệu thuộc kiểu cấu trúc ADC để cài đặt các giá trị đã khởi tạo ở trên.
	//trên.

	ADC_RegularChannelConfig(ADC1, ADC_Channel_15, 1, ADC_SampleTime_15Cycles);//Sử dụng hàm ADC_RegularChannelConfig với các đối số là ADC1,
	//kênh được kết nối với cảm biến nhiệt độ,

	ADC_TempSensorVrefintCmd(ENABLE); //Sử dụng hàm ADC_TempSensorVrefintCmd để sử dụng cảm biến
	//nhiệt độ bên trong vi điều khiển.
	ADC_Cmd(ADC1,ENABLE); //Sử dụng hàm ADC_Cmd để sử dụng bộ ADC1.

}


/*
 * @func   led_control_timer_oc_init
 * @brief  Initialize ouput
 * @param  None
 * @retval None
 */
static void_t led_control_timer_oc_init(void_t)
{
	GPIO_InitTypeDef           GPIO_InitStructure; //Cấu hình chân GPIO sử dụng cho chức năng PWM
	TIM_TimeBaseInitTypeDef    TIM_TimeBaseInitStructure; // Sử dụng struct TIM_TimeBase
	TIM_OCInitTypeDef          TIM_OCInitStructure;// Sử dụng struct TIM_OCI

	//Enable clock GPIOA
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); //Cấp clock sử dụng GPIOA.

	//Initializes GPIO Use Output Compare
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; // Chọn chế độ trên chân GPIO là Alternate function.
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //Chọn tốc độ trên chân GPIO là 50MHz
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; // Chọn chế độ điều khiển là đẩy kéo Push Pull
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ; //Chọn trạng thái ban đầu trên chân GPIO là thả treo

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_TIM1); //với đối số là GPIOA, chân PA11 làm chức năng Alternate function và sử dụng Mode AF cho Timer 1.


	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; //Sử dụng chân PA11 làm chức năng PWM.
	GPIO_Init(GPIOA, &GPIO_InitStructure); // Khởi tạo GPIO

	//Enable Timer1
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); //Kết nối clock sử dụng Timer1.

	//Initializes Tim Base F= 10khz
	TIM_TimeBaseInitStructure.TIM_Prescaler = 0; //Chọn hệ số chia tần là 0.
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //Chọn chế độ đếm lên
	TIM_TimeBaseInitStructure.TIM_Period = Tim_Period; //Hệ số tràn timer là 8399 để tạo ra tần số là 10KH
	TIM_TimeBaseInitStructure.TIM_ClockDivision = 0; // Hệ số chia tần sử dụng Timer.
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//Chọn bộ đến lặp lại là 0.

	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseInitStructure); // Khởi tạo TimeBase

    //Initializes Tim Output Compare
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; /// Chế độ PWM là TIM_OCMode_PWM2.
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;//Cho phép hoặc không cho phép chân pwm hoạt động

	TIM_OCInitStructure.TIM_Pulse = 0; //Đây chính là thông số quyết định duty cycle
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;//nếu polarity bit là 1 thì output sẽ ra mức cao tại lúc bắt đầu chu kỳ và sau đó xuống mức thấp tại thời điểm kết thúc chu kỳ



	TIM_OC4Init(TIM1, &TIM_OCInitStructure);//tham số truyền vào là Timer đang được sử dụng và biến dữ liệu thuộc kiểu cấu trúc PWM cho phép kênh 4 của Timer 1 hoạt động

	TIM_Cmd(TIM1, ENABLE); //Cho phép Timer 1 hoạt động.

	TIM_CtrlPWMOutputs(TIM1, ENABLE); //Cho phép Timer với Chức năng PWM hoạt độn
}

/*
 * @func   usart_init
 * @brief  Initialize Usart
 * @param  None
 * @retval None
 */
static void_t usart_init(void_t)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;

    //Enable GPIO clock --------------------------------------------------------
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);

    //Configure USART Tx as alternate function push-pull------------------------
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;

    //Connect USART pins--------------------------------------------------------
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

	//Enable USART clock--------------------------------------------------------
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);

    USART_InitStructure.USART_BaudRate = 57600;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Tx;

    USART_Init(USART2, &USART_InitStructure);

	//Enable USART--------------------------------------------------------------
    USART_Cmd(USART2, ENABLE);
}


/*
 * @func   multi_sensor_scan
 * @brief  Update light value sensor
 * @param  None
 * @retval None
 */
static void_t multi_sensor_scan(void_t)
{
	g_dwTimeCurrent = GetMilSecTick();
	if(g_dwTimeCurrent >= g_dwTimeInitial)
		{
			g_dwTimeTotal += g_dwTimeCurrent - g_dwTimeInitial;
		}
	else
		{
			g_dwTimeTotal += 0xFFFFFFFFU - g_dwTimeCurrent + g_dwTimeInitial;
		}
	if(g_dwTimeTotal >= TIME_abl_process)
		{
			g_dwTimeTotal = 0;

			abl_process();
		}
	g_dwTimeInitial = g_dwTimeCurrent;
}

/*
 * @func   light_sensor_adc_polling_read
 * @brief  Read Light Sensor ADC Polling Regime
 * @param  None
 * @retval Light Value
 */
static u16_t
light_sensor_adc_polling_read(void_t)
{
	u16_t wResult = 0;

	ADC_SoftwareStartConv(ADC1); // Yêu cầu độc dữ liệu từ ADC1

	while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);//chờ thực hiện xong quá trình chuyển đổi ADC.

	wResult = ADC_GetConversionValue(ADC1); // Gán giá trị nhận được vào biến
	return wResult; // trả về giá trị nhận được
}

/*
 * @func   cover_light
 * @brief  Send Light Value to USART
 * @param  None
 * @retval None
 */
static
void_t cover_light(void_t)
{
	u16_t wLight;

	ADC_SoftwareStartConv(ADC1);

	while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);

	wLight = ADC_GetConversionValue(ADC1);

	u8_t wLightHigh = (u8_t)(light >>8) ;
	u8_t wLightLow = (u8_t)(light & 0xFF);
	USART_SendData(USART2,wLightHigh);
	delay_ms(5);
	USART_SendData(USART2,wLightLow);
}

/*
 * @func   led_control_timer_oc_set_pwm
 * @brief  Control Output Compare Led
 * @param  duty Cycle
 * @retval None
 */
static
void_t led_control_timer_oc_set_pwm(u16_t wDutyCycle)
{
	static u16_t wPulseLength = 0;

	//Calculator wPulseLength
	wPulseLength = ((Tim_Period * wDutyCycle) / 100) ;

	TIM_SetCompare4(TIM1, wPulseLength); // Điều khiển led theo wPulseLength
}

/*
 * @func   light_filter
 * @brief  light_filter
 * @param  Light Value nedd Filter
 * @retval None
 */
static
u16_t light_filter(u16_t wLightFilter)
{
	u16_t wLightFilter1Times = 0;
	u16_t wLightFilter1Times2 = 0;

	wLightFilter1Times = KalmanFilter_updateEstimate(wLightFilter); // Xử lý giá trị ánh sáng nhận được qua bộ lọc filter 2 lần
	wLightFilter1Times2 = KalmanFilter_updateEstimate(wLightFilter1Times);

	return wLightFilter1Times2; // Trả lại giá trị khi đã lõ xong
}

/*
 * @func   abl_step_brightness
 * @brief  abl_step_brightness
 * @param  Blightness need convert
 * @retval None
 */
static
u8_t abl_step_brightness(u16_t wLightBrightness)
{
	float_t dwLightScale;
	dwLightScale = (float)wLightBrightness*100/(float)4096; // PWM  = max 100 và light max = 2^16 nên chia 4096
	return (u8_t)dwLightScale; // Trả lại giá trị đã chuyển đổi
}


/*
 * @func   abl_process
 * @brief  Process ABL
 * @param  None
 * @retval None
 */
static
void_t abl_process(void_t)
{
	u8_t wDutyCycles; // giá trị cần truyền vào hàm điều khiển led
	g_wLightValue = light_sensor_adc_polling_read(); // Đo giá trị thô của ánh sáng
	g_wLightValue = light_filter(g_wLightValue); // sử dụng bộ lọc filter
	wDutyCycles = abl_step_brightness(g_wLightValue); // Lấy giá trị của wDutyCycle
	led_control_timer_oc_set_pwm(wDutyCycles); // Điều khiển led
}

static
void_t delay_ms(uint32_t milisecond)
{
	for(uint32_t i= 0;i<milisecond;i++)
	{
		for(uint32_t j=0;j<5000;j++);
	}
}
