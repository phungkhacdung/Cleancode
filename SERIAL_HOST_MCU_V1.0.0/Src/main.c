
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
*******************************************************************************
 *				 _ _                                             _ _
				|   |                                           (_ _)
				|   |        _ _     _ _   _ _ _ _ _ _ _ _ _ _   _ _
				|   |       |   |   |   | |    _ _     _ _    | |   |
				|   |       |   |   |   | |   |   |   |   |   | |   |
				|   |       |   |   |   | |   |   |   |   |   | |   |
				|   |_ _ _  |   |_ _|   | |   |   |   |   |   | |   |
				|_ _ _ _ _| |_ _ _ _ _ _| |_ _|   |_ _|   |_ _| |_ _|
								(C)2022 Lumi
 * Copyright (c) 2022
 * Lumi, JSC.
 * All Rights Reserved
 *
 * File name: main.h
 *
 * Description:
 *
 *
 * Last Changed By:  $Author: dungpk $
 * Revision:         $Revision: $
 * Last Changed:     $Date: $June 1, 2022
 *
 * Code sample:
 ******************************************************************************/
/******************************************************************************/
/*                              INCLUDE FILES                                 */
/******************************************************************************/
#include <stdint.h>
#include "buff.h"
#include "serial.h"
#include "stdio.h"
#include "string.h"
#include "timer.h"
#include "led.h"
#include "melody.h"
#include "gLightValuesensor.h"
#include "temhumsensor.h"
#include "eventbutton.h"
#include "Ucglib.h"
#include "uartcmd.h"
#include "stm32f401re_gpio.h"
#include "stm32f401re_usart.h"
#include "stm32f401re_rcc.h"
#include "misc.h"
#include "buff.h"
#include "stm32f401re_tim.h"

/******************************************************************************/
/*                     PRIVATE TYPES and DEFINITIONS                         */
/******************************************************************************/
/******************************************************************************/
/*                     EXPORTED TYPES and DEFINITIONS                         */
/******************************************************************************/

#define CYCLE_SEND_DATA 				2000 //ms

#define CMD_TEMHUM_gLightValue			0x82 // Dinh nghia Trường Command ID Temhum

#define NUM_ID_LED_LEFT					0x01 // Dinh nghia Num_id led trai
#define NUM_ID_LED_RIGHT				0x02 // Dinh nghia num_id led phai

#define RED_COLOR	   					0x00 // Dinh nghia led do
#define GREEN_COLOR						0x01 // Dinh nghia le xanh la
#define BLUE_COLOR						0x02 // Dinh nghia led blue

#define SIZE_QUEUE_DATA_RX				256 // do dai cua queue

#define FRAME_SIZE_MAX					9 // Frame max

#define USART2_TX						GPIO_Pin_2 // Dinh nghia chan TX
#define USART2_RX						GPIO_Pin_3 // Dinh nghia chan Rx
#define USART2_GPIO						GPIOA // Dinh nghia GPIO cua USART
#define USART2_GPIO_CLOCK				RCC_AHB1Periph_GPIOA // Dinh nghia GPIO can cap xung clovk
#define USART2_CLOCK					RCC_APB1Periph_USART2 // Dinh nghia ngoai vi usart can cap xung clock

#define USARTx_Baud						57600 // Toc do truyen nhan uart

enum{
		RESET = 0,
		SET = 1
};

/******************************************************************************/
/*                              PRIVATE DATA                                  */
/******************************************************************************/

/******************************************************************************/
/*                              EXPORTED DATA                                 */
/******************************************************************************/

u8_t byRxBuffer[RX_BUFFER_SIZE] = {0}; // Bien luu gia tri cua frame
static u8_t g_byRxBuffer; // Bien luu trang thai cua usart
static u8_t g_byIndexRxBuf; // Bien dem frame de xu lty
static u8_t g_byCheckXorRxBuf; // Bien luu gia tri de check xor
static buffqueue_t serialQueueRx; // Bien khoi tao queue
static u8_t g_pBuffDataRx[SIZE_QUEUE_DATA_RX]; // Bien luu gia tri cua frame
static ucg_t ucg; // Bien ucg_t su dung hien thi LCD

static bool_t g_boCheckTemHumSignalRequest = RESET; // Bien nhan tin hieu cap nhat nhiet do do am va anh sang
static bool_t g_boCheckBuzzerSignalRequest = RESET; // Bien nhan tin hieu bat tat coi
static bool_t g_boCheckLed_RedLeft = RESET;// Bien nhan tin hieu bat tat led do trai
static bool_t g_boCheckLed_RedRight = RESET; // Bien nhan tin hieu bat tat led do phai
static bool_t g_boCheckLed_BlueLeft = RESET;// Bien nhan tin hieu bat tat led xannh duong trai
static bool_t g_boCheckLed_BlueRight = RESET;// Bien nhan tin hieu bat tat led xanh duong phai
static bool_t g_boCheckLed_GreenRight = RESET;// Bien nhan tin hieu bat tat led xanh la trai
static bool_t g_boCheckLed_GreenLeft = RESET;// Bien nhan tin hieu bat tat led xanh la phai

static u32_t gTime_Current,gTime_Initial;  // Khai bao bien thoi gian tinh thoi gian cho cap nhat nhiet do, do am,do sang
static u32_t gTime_Total;   // Khai bao bien luu tong thoi gian cho cap nhat tem,hum,gLightValue
static u8_t gTemperatureValue,gHumidityValue; // Bien luu gia tri nhiet do, do am
static u16_t gLightValue; // Bien luu gia tri do sang
/******************************************************************************/
/*                            PRIVATE FUNCTIONS                               */
/******************************************************************************/

/******************************************************************************/
/*                            EXPORTED FUNCTIONS                              */
/******************************************************************************/

static void_t USART2_Init(void_t); // Ham khoi tao usart
static void_t delay_ms(u32_t milisecond); // Ham delay cho xu ly du lieu
static u8_t PollRxBuff(void_t); // Ham để xử lý các bản tin nhận được theo định dạng.
static void_t Serial_Init2(void_t); // Ham khoi tao usart va khoi tao queue
static void_t UartCommandProcess1(void_t *arg); //Ham kiem tra du lieu nhan ve de xu ly
static void_t MultiSensorScan(void_t);  // Ham hien thi nhiet do, do am, do sang len LCD
static void_t  Task_multiSensorScan (void_t);  // Ham cap nhat thoi gian thuc de cap nhat nhiet do, do am, do sang
static void_t Send_Tem_Hum(u8_t id,u8_t cmd,u8_t value); // Ham gui gia tri nhiet do va do ma len mo phong
static void_t Send_gLightValue(u8_t id,u8_t cmd,u16_t value); // Ham gui gia tri anh sang len mo phong
static void_t LCD_Init(void_t);
static void_t application_Init(void_t);

/******************************************************************************/


int main(void_t)
{
	u8_t stateRx; // Bien luu trang thai cua Rx
	application_Init();
	//Khoi tao LCD
	LCD_Init();
	while(1)
	{
		processTimerScheduler();
		stateRx = PollRxBuff(); // Xet trang thai cua RX

		if(stateRx != UART_STATE_IDLE)
		{
			switch(stateRx)
			{
				case UART_STATE_ACK_RECEIVED:
					break;

				case UART_STATE_NACK_RECEIVED:
					break;

				case UART_STATE_DATA_RECEIVED:
					UartCommandProcess1(&byRxBuffer[2]); // Luu du lieu can xu luy vao bo dem
					break;

				case UART_STATE_ERROR:
				case UART_STATE_RX_TIMEOUT:
					break;
				default:
					break;
			}
		}
		if(g_boCheckTemHumSignalRequest == SET) // kiem tra co tin hieu cap nhat nhiet do do am se bat dau gui du lieu len mo phong
		{
			MultiSensorScan();
			g_boCheckTemHumSignalRequest = RESET;
		}

	}
}

static void_t application_Init(void_t)
{
		SystemCoreClockUpdate(); // Ham cap xung
		TimerInit(); // Khoi tao timer
		gLightValueSensor_Init(ADC_READ_MODE_DMA); // Ham khoi tao cam bien anh sang su dung che do quet DMA
		TemHumSensor_Init(); // Ham khoi tao cam bien nhiet do do am
		Serial_Init2();// Ham khoi tao usart va khoi tao queue
		BuzzerControl_Init(); // Ham khoi tao buzzer
		LedControl_Init(); // Ham dieu khien led
}

static void_t LCD_Init(void_t)
{
		Ucglib4WireSWSPI_begin(&ucg,UCG_FONT_MODE_SOLID);
		ucg_ClearScreen(&ucg);
		ucg_SetFont(&ucg, ucg_font_ncenR12_hr);
		ucg_SetColor(&ucg, 0, 255, 255, 255);
		ucg_SetColor(&ucg, 1, 0, 0, 0);
		ucg_SetRotate180(&ucg);
}
static
static void_t USART2_Init(void_t)
{
	/*GPIO*/
	GPIO_InitTypeDef		GPIO_InitStructure; //Khai báo biến thuộc kiểu dữ liệu struct GPIO.
	USART_InitTypeDef		USART_InitStructure; //Khai báo biến thuộc kiểu dữ liệu struct USART.
	NVIC_InitTypeDef		NVIC_InitStructure; // Khai báo biến thuộc kiểu dữ liệu struct NVIC

	RCC_AHB1PeriphClockCmd(USART2_GPIO_CLOCK,ENABLE);//Kết nối clock cho USART2

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; //Chọn chế trên chân GPIO sử dụng cho USART1 là Alternate Function.
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//Chọn Tốc độ trên chân là 100MHz.
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//Chọn chế độ điều khiển trên chân là Push Pull.
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //Chọn trạng thái trên chân ban đầu là kéo trở lên dương nguồn Pull Up.

	GPIO_InitStructure.GPIO_Pin = USART2_TX; //chon chan TX
	GPIO_Init(USART2_GPIO,&GPIO_InitStructure); // Khoi tao GPIO

	GPIO_PinAFConfig(USART2_GPIO,GPIO_PinSource2,GPIO_AF_USART2);// Su dung chuc nang AF

	GPIO_InitStructure.GPIO_Pin = USART2_RX;// chon chan Rx
	GPIO_Init(USART2_GPIO,&GPIO_InitStructure);// KHoi tao GOPIO

	GPIO_PinAFConfig(USART2_GPIO,GPIO_PinSource3,GPIO_AF_USART2); // Su dung chuc nang AF

	/*USART*/
	RCC_APB1PeriphClockCmd(USART2_CLOCK, ENABLE); //Cấp clock để sử dụng ngoại vi USART2.

	USART_InitStructure.USART_BaudRate = USARTx_Baud; //Cấu hình tốc độ truyền là 57600.
	USART_InitStructure.USART_WordLength = USART_WordLength_8b; //Khung truyền 8 bit dữ liệu.
	USART_InitStructure.USART_StopBits = USART_StopBits_1; //Khung truyền có một bit Stop.
	USART_InitStructure.USART_Parity = USART_Parity_No; //Không sử dụng bit Parity.
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //Cho phép quá trình nhận bởi phần cứng.
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //Chức năng truyen nhan

	USART_Init(USART2,&USART_InitStructure); //Sử dụng hàm USART_Init để cài đặt các giá trị đã khởi tạo ở trên.

	USART_Cmd(USART2,ENABLE);//Cho phép bộ USART1 hoạt động.



	/*NIVIC*/

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; //Cho phép sử dụng ngắt ngoại vi USART2.
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //Sử dụng ưu tiên ngắt PreemptionPriority là 0.
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; //Sử dụng ưu tiên ngắt SubPriority là 0.
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//Sử dụng trình phục vụ ngắt với USART1.

	NVIC_Init(&NVIC_InitStructure);

	USART_ITConfig(USART2,USART_IT_RXNE,ENABLE);

}


static
void_t USART2_IRQHandler(void_t)
{
	u8_t frame;
	//Kiểm tra dữ liệu là đã được gửi đến USART2.
	if( USART_GetITStatus(USART2,USART_IT_RXNE) == SET )
	{
		// Luu gia tri vao frame
		frame = USART_ReceiveData(USART2);
		bufEnDat(&serialQueueRx, (u8_t *)&frame);

	}
	//Gọi hàm USART_ClearITPendingBit để thoát khỏi hàm xử lý ngắt.
	USART_ClearITPendingBit(USART2,USART_IT_RXNE);
}

static
void_t delay_ms(u32_t milisecond)
{
	for(u32_t i= 0;i<milisecond;i++)
	{
		for(u32_t j=0;j<5000;j++);
	}
}

static
u8_t PollRxBuff(void_t)
{
	u8_t byRxData;
	u8_t byUartState = (u8_t)UART_STATE_IDLE;

	//Kiểm tra bộ đệm FIFO có phần tử hay không, nếu có sử dụng hàm bufDeDat để lấy phần tử từ bộ đệm FIFO để bắt đầu xử lý.
	while((bufNumItems(&serialQueueRx) != 0) && (byUartState == UART_STATE_IDLE))
	{
		//Lay du lieu tu bo dem de bat dau xu ly
		bufDeDat(&serialQueueRx, &byRxData);
		switch(g_byRxBuffer)
		{
		// Truong hop Rx nhan tin hieu bat dau
		case RX_STATE_START_BYTE:
			if(byRxData == FRAME_SOF)
			{
				g_byIndexRxBuf = 0; // Khoi tao gia tri dau tien cua du lieu can xu ly
				g_byCheckXorRxBuf = CXOR_INIT_VAL; // Khoi tao gia tri de check xor
				g_byRxBuffer = RX_STATE_DATA_BYTES; //Doi trang thai cua RX dang nhan du lieu can xu ly
			}
			else if(byRxData == FRAME_ACK) // Truong hop du lieu nhan duoc la ack
			{
				byUartState = UART_STATE_ACK_RECEIVED; // Dat trang thai cua USART la nhan du lieu ack
			}
			else if (byRxData == FRAME_NACK) // Truong hop du lieu nhan duoc la nack
			{
				byUartState = UART_STATE_NACK_RECEIVED; // Dat trang thai USART la nhan du lieu NACK
			}
			else {
				byUartState = UART_STATE_ERROR; // Truong hop nhan du lieu bi loi
			}
			break;
		case RX_STATE_DATA_BYTES: // TRuong hop xu ly du lieu nhan duoc
			if(g_byIndexRxBuf < RX_BUFFER_SIZE) // Kiem tra du lieu nhan ve co nho hon 30 khong
			{
				byRxBuffer[g_byIndexRxBuf] = byRxData;// Luu du lieu vao buffer
				if(g_byIndexRxBuf > 0)
				{
					g_byCheckXorRxBuf ^= byRxData; // Luu gia tri check xor
				}
				if (++g_byIndexRxBuf == *byRxBuffer) // Kiem tra so luong du lieu nhan ve
				{
					g_byRxBuffer = RX_STATE_CXOR_BYTE; // Truong hop xet check xor
				}
			}
			else
			{
				g_byRxBuffer = RX_STATE_START_BYTE;
				byUartState = UART_STATE_ERROR;
			}
			break;

		case RX_STATE_CXOR_BYTE: // Truong hop xu ly check xor
			if (byRxData == g_byCheckXorRxBuf) //Neu nhan dung nhung gia tri nhan ve
			{
				byUartState = UART_STATE_DATA_RECEIVED; // Doi trang thai cua cua USART
			}
			else {
				byUartState = UART_STATE_ERROR; // Dat trang thai loi khi nhan du lieu
			}

		default:
			g_byRxBuffer = RX_STATE_START_BYTE;
			break;
		}
	}
	return byUartState; // Tra ve trang thai cua USART
}

static
void_t Serial_Init2(void_t)
{
	USART2_Init(); // Khoi tao usart
	bufInit(g_pBuffDataRx,&serialQueueRx,sizeof(g_pBuffDataRx[0]),SIZE_QUEUE_DATA_RX); // Khoi tao bo dem queue
}


static
void_t UartCommandProcess1(void_t *arg)
{

	char *str = &byRxBuffer[4]; //Luu con tro gui du lieu len mo phong
	cmd_common_t *pCmd = (cmd_common_t*)arg; // Struct cmd_common_t de lay cmd cua tung thiet bi
	cmd_led_indicator_t *led_indicator = (cmd_led_indicator_t *)arg; // cmd_led de xu ly thiet bi led
	    switch (pCmd ->cmdid) // xet tung truong hop thiet bi can duoc dieu khien
	    {
	    	case CMD_ID_DEVICE:
	    		Serial_SendPacket(0,CMD_ID_DEVICE,CMD_TYPE_RES,0x00,1);
	    		break;
	    	case CMD_ID_LED: // Xet truong led
	    		if(led_indicator ->numID == NUM_ID_LED_LEFT) // Kiem tra du lieu nhan duoc led number can duoc bat tat
	    		{
	    			if(led_indicator->color == GREEN_COLOR) // Kiem tra mau cua led can duoc bat tat
	    			{
	    				g_boCheckLed_GreenRight = !g_boCheckLed_GreenRight; // Dao gia tri cua led green ben trai board
	    				//Bat tat led green
		    			LedControl_SetColorIndividual(LED_KIT_ID1,LED_COLOR_GREEN,(u8_t)g_boCheckLed_GreenRight*100);
	    			}
	       			if(led_indicator->color == BLUE_COLOR)  // Kiem tra du lieu nhan duoc led number can duoc bat tat
	    	    	{
	    	    		g_boCheckLed_BlueLeft = !g_boCheckLed_BlueLeft; // Kiem tra mau cua led can duoc bat tat
	    	    		// Dao gia tri cua led blue ben trai board
	    		    	LedControl_SetColorIndividual(LED_KIT_ID1,LED_COLOR_BLUE,(u8_t)g_boCheckLed_BlueLeft*100);
	    	    	}
	       			if(led_indicator->color == RED_COLOR) // Kiem tra du lieu nhan duoc led number can duoc bat tat
	    	    	{
	    	    		g_boCheckLed_RedLeft = !g_boCheckLed_RedLeft;  // Dao gia tri cua led red ben trai board
	    	    		// Dao gia tri cua led blue ben  board
	    		   		LedControl_SetColorIndividual(LED_KIT_ID1,LED_COLOR_RED,(u8_t)g_boCheckLed_RedLeft*100);
	    	    	}
	    		}

	    		// Tuong tu voi led green blue va red ben phai cua board
	    		if(led_indicator ->numID == NUM_ID_LED_RIGHT)
	    		{
	    			if(led_indicator->color == GREEN_COLOR)
	    			{
	    				g_boCheckLed_GreenLeft = !g_boCheckLed_GreenLeft;
		    			LedControl_SetColorIndividual(LED_KIT_ID0,LED_COLOR_GREEN,(u8_t)g_boCheckLed_GreenLeft*100);
	    			}
	       			if(led_indicator->color == BLUE_COLOR)
	    	    	{
	    	    		g_boCheckLed_BlueRight = !g_boCheckLed_BlueRight;
	    		    	LedControl_SetColorIndividual(LED_KIT_ID0,LED_COLOR_BLUE,(u8_t)g_boCheckLed_BlueRight*100);
	    	    	}
	       			if(led_indicator->color == RED_COLOR)
	    	    	{
	    	    		g_boCheckLed_RedRight = !g_boCheckLed_RedRight;
	    		   		LedControl_SetColorIndividual(LED_KIT_ID0,LED_COLOR_RED,(u8_t)g_boCheckLed_RedRight*100);
	    	    	}
	    		}
	    		break;
	    		break;
	    	case CMD_ID_BUZZER: // Truong hop dieu khien coi
	    		g_boCheckBuzzerSignalRequest = !g_boCheckBuzzerSignalRequest; // Dao trang thai cua bien can dieu khien
	    		if(g_boCheckBuzzerSignalRequest == 1)
	    		{
	    			BuzzerControl_SetDutyCycle(50); // Bat coi
	    		}
	    		else
	    			BuzzerControl_SetDutyCycle(0); // Tat coi
	    		break;
	    	// Test khi dung ham san Serial_SendPacket
	    	// khong co cung khong sao
	    	case CMD_ID_gLightValue_SENSOR:
	    		Serial_SendPacket(0,CMD_ID_gLightValue_SENSOR,CMD_TYPE_RES,(u8_t*)&gLightValue,sizeof(gLightValue));
	    		break;
	    	case CMD_ID_TEMP_SENSOR:
	    		Serial_SendPacket(0,CMD_ID_TEMP_SENSOR,CMD_TYPE_RES,(u8_t*)&gTemperatureValue,sizeof(gTemperatureValue));
	    		break;
	    	case CMD_ID_HUMI_SENSOR:
	    		Serial_SendPacket(0,CMD_ID_HUMI_SENSOR,CMD_TYPE_RES,(u8_t*)&gHumidityValue,sizeof(gHumidityValue));
	    		break;
	    	case CMD_ID_LCD: // truong hop can hien thi du lieu len LCD
	    		ucg_ClearScreen(&ucg); // xoa man hinh
	    		ucg_SetFont(&ucg,ucg_font_ncenR08_hr); // Dat lai phong chu
	    		ucg_DrawString(&ucg,0,10,0,str); // Dat lai toa do can hien thi

	    		break;
	    	case CMD_TEMHUM_gLightValue: // Truong hop can cap nhat thong tin len tren mo phong
	    		g_boCheckTemHumSignalRequest = SET;
	    	default:
	    		break;
	    }

}

static
void_t  Task_multiSensorScan (void_t)
{
	gLightValue = gLightValueSensor_MeasureUseDMAMode(); // doc gia tri cua anh sang
	gTemperatureValue = (u8_t)(TemHumSensor_GetTemp()/100); // doc gia tri cua nhiet do
	gHumidityValue = (u8_t)(TemHumSensor_GetHumi()/100); // Doc gia tri cua do am
	Send_Tem_Hum(CMD_ID_HUMI_SENSOR,CMD_TYPE_RES,gHumidityValue); // Gui gia tri len mo phong
	Send_Tem_Hum(CMD_ID_TEMP_SENSOR,CMD_TYPE_RES,gTemperatureValue); // Gui gia tri len mo phong
	Send_gLightValue(CMD_ID_gLightValue_SENSOR,CMD_TYPE_RES,gLightValue);// Gui gia tri len mo phong
}

static
void_t MultiSensorScan()
{
	gTime_Current = GetMilSecTick();// Khoi tao thoi gian hien tai de dem
		if(gTime_Current >= gTime_Initial)
			{
				gTime_Total += gTime_Current - gTime_Initial;
			}
		else
			{
				gTime_Total += 0xFFFFFFFFU - gTime_Current + gTime_Initial;
			}
		if(gTime_Total >= CYCLE_SEND_DATA)
			{
				gTime_Total = 0;
				Task_multiSensorScan(); // cap nhat gia tri len mo phong
			}
		gTime_Initial = gTime_Current;
}


static
void_t Send_Tem_Hum(u8_t id,u8_t cmd,u8_t value)
{
	u8_t checkXor = 0xFF^id^cmd^value;// bien check xor gui len mo phong
	u8_t arr[9] = { 0xB1,0x07,0x00,id,cmd,0x00,value,0x00,checkXor}; // Bien luu frame can gui len mo phong

	for(int i=0;i<9;i++)
	{
		USART_SendData(USART2,arr[i]); // Gui tung frame len mo phong

		delay_ms(5); // cho cho du lieu gui xong
	}

}

static
void_t Send_gLightValue(u8_t id,u8_t cmd,u16_t value)
{
	u8_t value1 = (u8_t)(value >>8) ; // Luu du lieu dau tien
	u8_t value2 = (u8_t)(value & 0xFF); // Luu du lieu thu 2
	u8_t checkXor = 0xFF^id^cmd^value1^value2^0x01; // Bien check xor can gui
	u16_t arr[9] = { 0xB1,0x07,0x00,id,cmd,value1,value2,0x01,checkXor}; // Frame can gui du lieu
	for(int i=0;i<9;i++)
	{
		USART_SendData(USART2,arr[i]); // Gui tung frame
		delay_ms(5); // Cho cho du lieu duoc gui va nhan
	}
}
