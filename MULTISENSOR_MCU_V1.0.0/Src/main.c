/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
*******************************************************************************
 *				 _ _                                             _ _
				|   |                                           (_ _)
				|   |        _ _     _ _   _ _ _ _ _ _ _ _ _ _   _ _
				|   |       |   |   |   | |    _ _     _ _    | |   |
				|   |       |   |   |   | |   |   |   |   |   | |   |
				|   |       |   |   |   | |   |   |   |   |   | |   |
				|   |_ _ _  |   |_ _|   | |   |   |   |   |   | |   |
				|_ _ _ _ _| |_ _ _ _ _ _| |_ _|   |_ _|   |_ _| |_ _|
								(C)2022 Lumi
 * Copyright (c) 2022
 * Lumi, JSC.
 * All Rights Reserved
 *
 * File name: main.h
 *
 * Description:
 *
 *
 * Last Changed By:  $Author: dungpk $
 * Revision:         $Revision: $
 * Last Changed:     $Date: $June 1, 2022
 *
 * Code sample:
 ******************************************************************************/
/******************************************************************************/
/*                              INCLUDE FILES                                 */
/******************************************************************************/
#include <stdint.h>
#include "temhumsensor.h"
#include "Ucglib.h"
#include "Ucg.h"
#include "timer.h"
#include "Stm32f401re_i2c.h"
#include <string.h>
#include <stdio.h>
#include "stm32f401re_rcc.h"
#include "stm32f401re_gpio.h"
#include "math.h"

/******************************************************************************/
/*                     PRIVATE TYPES and DEFINITIONS                         */
/******************************************************************************/

/*Khoi tao SPI giao tiep voi LCD*/

#define SPI1_CS_PORT				GPIOB
#define SPI1_CS_PIN					GPIO_Pin_6
#define SPI1_RST_PORT				GPIOC
#define SPI1_RST_PIN				GPIO_Pin_7
#define	SPI1_MOSI_PORT				GPIOA
#define SPI1_MOSI_PIN				GPIO_Pin_7
#define SPI1_SCK_PORT				GPIOA
#define SPI1_SCK_PIN				GPIO_pin_5
#define SPI1_RS_PORT				GPIOA
#define SPI1_RS_PIN					GPIO_pin_9
#define SPI1_ENABLE_PORT			GPIOB
#define SPI1_ENABLE_PIN				GPIO_pin_10
#define SPI1_MODE_PORT				GPIOA
#define SPI1_MODE_PIN				GPIO_pin_8


TIME_UPDATE_TEMHUM					10

#define CYCLE_SEND_DATA 			5000 // ms
#define CYCLE_UPDATE_DATA			100 //ms
/*I2C*/

#define SERIAL_ADR					0x40 // Dia chi cua cam bien
#define VALUE_HMM_REG            0xE5 // Dia chi thanh ghi do am
#define VALUE_HMM_REG         0xE3 // Dia chi thanh ghi nhiet do


#define I2C_SPEED					400000 // Toc do truyen nhan

#define I2C_MASTER_RCC				RCC_APB1Periph_I2C1 //Dinh nghia ngoai bus can cap xung clock
#define I2C_MASTER_INSTANCE			I2C1

#define I2C_MASTER_GPIO_RCC			RCC_AHB1Periph_GPIOB // Dinh nghia GPIO can cap xung clock
#define I2C_MASTER_PORT				GPIOB // Ddinh nghia GPIO can dung
#define SDA_MASTER_PIN				GPIO_Pin_9 // Dinh nghia chan SDA
#define SCL_MASTER_PIN				GPIO_Pin_8 // Dinh nghia chan SCL

/******************************************************************************/
/*                     EXPORTED TYPES and DEFINITIONS                         */
/******************************************************************************/

/******************************************************************************/
/*                              PRIVATE DATA                                  */
/******************************************************************************/

/******************************************************************************/
/*                              EXPORTED DATA                                 */
/******************************************************************************/

static u8_t g_byCountTimesUpdatewValue_TemHum = 0; // Khoi tao bo dem so lan cap nhat nhiet do do am len LCD
static u32_t g_dwTimeCurretMeasureTemHum,g_dwTimeInitialMeasureTemHum; // Bien xac dinh thoi gian hien tai va thoi gian khoi tao
static u32_t g_dwTimeTotalMeasureTemHum; // Bien tinh tong thoi gian
static u8_t g_bywValue_Temerature_Value,g_bywValue_Humidity_Value; // Bien luu gia tri cua nhiet do do am
static ucg_t ucg;// bien ucg de su dung lCD
static i8_t g_ibTemString[20]= ""; // Bien i8_t dung de ep kieu hien thi len LCD
static i8_t g_ibwValue_HumiString[20]= "";// Bien i8_t dung de ep kieu hien thi len LCD
static u8_t g_byValueRegister; // Bien luu gia tri cua thanh ghi

static float_t_t g_dw_err_measure_wValue_Temerature = 0; // Khai bao bien loi do luong nhiet do dung trong bo loc kanmal
static float_t g_dw_err_estimate_wValue_Temerature = 0; // khai bao bien loi uoc tinh dung trong bo loc kanmal
static float_t g_dw_error_number_wValue_Tem  = 0; // khai bao bien luu gia tri sai so trong bo loc kanmal
static float_t g_dw_current_estimate_wValue_Temerature = 0; // khai bao bien luu gia tri hien tai khi qua bo loc
static float_t g_dw_last_estimate_wValue_Temerature = 0; // khai bao bien luu gia tri gan nhat khi loc
static float_t g_dw_kalman_gain_wValue_Tem_wValue_Temerature = 0; //khai bao bien de tinh toan kanmal

static float_t g_dw_err_measure_wValue_Humidity = 0;// Khai bao bien loi do luong do am dung trong bo loc kanmal
static float_t g_dw_err_estimate_wValue_Humidity = 0;// khai bao bien loi uoc tinh dung trong bo loc kanmal
static float_t g_dw_error_number_wValue_Humidity = 0;// khai bao bien luu gia tri sai so trong bo loc kanmal
static float_t g_dw_current_estimate_wValue_Humidity = 0;// khai bao bien luu gia tri hien tai khi qua bo loc
static float_t g_dw_last_estimate_wValue_Humidity = 0;// khai bao bien luu gia tri gan nhat khi loc
static float_t g_dw_kalman_gain_wValue_Tem_wValue_Humidity = 0;//khai bao bien de tinh toan kanmal

/******************************************************************************/
/*                            PRIVATE FUNCTIONS                               */
/******************************************************************************/

/******************************************************************************/
/*                            EXPORTED FUNCTIONS                              */
/******************************************************************************/

void temhum_sensor_init(void); // khởi tạo I2C của vi điều khiển STM32F401 để giao tiếp với cảm biến nhiệt độ - độ ẩm.
void i2c_start (void);//hàm i2c_start để truyền bit star
void i2c_address_direction(u8_t address, u8_t direction); //hàm i2c_address_direction truyền bit địa chỉ với 2 tham số là địa chỉ và truyền hay nhận dữ liệu:
void i2c_transmit(u8_t data);//hàm i2c_transmit để truyền địa chỉ lấy dữ liệu của các thanh ghi trong cảm biến
void i2c_stop(void);//hàm i2c_stop để hoàn tất quá trình truyền dữ liệu:
u8_t i2c_receive_ack(void);//hàm i2c_receive_nack nhận dữ liệu:
u8_t i2c_receive_nack(void);//hàm i2c_receive_ack nhận dữ liệu
u8_t temhum_sensor_readregister(u8_t address_temhum, u8_t address_register,u8_t size, u8_t time_delay);// hàm temhum_sensor_readregister giao tiếp với các thanh ghi trong cảm biến để đọc giá trị nhiệt độ, độ ẩm gồm 5 tham số:
u8_t Value_Temp_sensor_get_wValue_Tem_value(void); //hàm Value_Temp_sensor_get_wValue_Tem_value xử lý dữ liệu nhiệt độ:
u8_t Value_Humi_sensor_get_wValue_Tem_value (void);// hàm Value_Humi_sensor_get_wValue_Tem_value xử lý dữ liệu độ ẩm
void process_get_value_sensor(void);//process_get_value_sensor xử lý dữ liệu nhiệt độ, độ ẩm sau 1s và in ra màn hình LCD:
void delay_ms(u32_t milisecond); // Ham delay
static void_t lcd_init(void_t)

void KalmanFilterInit_wValue_Tem(float_t mea_e, float_t est_e, float_t q); // Ham khoi tao KalmanFilter cho wValue_Tem
float_t KalmanFilter_updateEstimate_wValue_Tem(float_t mea);// Ham xu ly nhiet do tho
void KalmanFilterInit_wValue_Humi(float_t mea_e, float_t est_e, float_t q); ;// Ham khoi tao KalmanFilter cho wValue_Humi
float_t KalmanFilter_updateEstimate_wValue_Humi(float_t mea); // Ham xu ly do am tho
static void_t appInitCommon(void_t)
/******************************************************************************/



int main(void)
{

	appInitCommon();
	
	while(1)
	{
		process_get_value_sensor();// lấy thông tin nhiệt độ, độ ẩm hiển thị lên LCD.
		processTimerScheduler(); //sử dụng timer quản lý các tác vụ khác nhau.
	}

}

/*
 * @func   appInitCommon
 * @brief  Initialize peripheral
 * @param  None
 * @retval None
 */
static void_t appInitCommon(void_t)
{
	SystemCoreClockUpdate();// Cấp xung clock cho vi điều khiển là 84 Mhz.
	TimerInit();//Sử dụng timer.
	temhum_sensor_init();//Sử dụng giao tiếp I2C.
	lcd_init();
	g_dwTimeInitialMeasureTemHum = GetMilSecTick();//Khởi tạo giá trị cập ban đầu của timer
	KalmanFilterInit_wValue_Tem(1,2,0.0001); // khoi tao bo loc kanmal voi tham so _err_measure = 1,estinamte = 2 va _q = 0.0001
	KalmanFilterInit_wValue_Humi(2,2,0.0001);// khoi tao bo loc kanmal voi tham so _err_measure = 2,estinamte = 2 va _q = 0.0001
}


/*
 * @func   lcd_init
 * @brief  Initialize LCD
 * @param  None
 * @retval None
 */
static void_t lcd_init(void_t)
{
	Ucglib4WireSWSPI_begin(&ucg,UCG_FONT_MODE_SOLID);//hàm khởi tạo LCD.
	ucg_ClearScreen(&ucg);//hàm xóa chữ trên LCD.
	ucg_SetFont(&ucg,ucg_font_ncenR12_hr);// là hàm cài đặt phông chữ trên LCD.
	ucg_SetColor(&ucg, 0, 255, 255, 255);// là hàm cài đặt màu nền cho LCD.
	ucg_SetColor(&ucg, 1, 0, 0, 0);// hàm cài đặt hướng hiển thị chữ trên LCD.
	ucg_SetRotate180(&ucg);//
}

/*
 * @func   temhum_sensor_init
 * @brief  Initialize wValue_Humidity sensor and temperature sensor
 * @param  None
 * @retval None
 */
void temhum_sensor_init(void)
{
		GPIO_InitTypeDef	GPIO_InitStruct;
		I2C_InitTypeDef		I2C_InitStruct;

		/*GPIO*/
		RCC_APB1PeriphClockCmd(I2C_MASTER_RCC,ENABLE); //Cấp xung clock cho ngoại vi
		RCC_AHB1PeriphClockCmd(I2C_MASTER_GPIO_RCC,ENABLE);//Cấp xung clock cho ngoại vi GPIOB

		GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;//Chọn chế độ trên 2 chân chọn làm SDA và SCL Alternate Function.
		GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; //Chọn tốc độ trên 2 chân được sử dụng là 50MHz.
		GPIO_InitStruct.GPIO_OType = GPIO_OType_OD; //Chọn chế độ điều khiển trên 2 chân là Open drain.
		GPIO_InitStruct.GPIO_PuPd  = GPIO_PuPd_UP; //Chọn trạng thái trở trên hai 2 chân là trạng thái trở treo lên PULL_UP.

		GPIO_InitStruct.GPIO_Pin = SDA_MASTER_PIN | SCL_MASTER_PIN; //Sử dụng chân SCL và  SDA.
		GPIO_Init(I2C_MASTER_PORT,&GPIO_InitStruct);//Sử dụng hàm GPIO_Init với tham số truyền vào là GPIO đang được
		//sử dụng và biến thuộc kiểu cấu trúc GPIO để cấu hình các giá trị được
		//khởi tạo

		GPIO_PinAFConfig(I2C_MASTER_PORT,GPIO_PinSource8,GPIO_AF_I2C1);//Sử dụng hàm GPIO_PinAFConfig với đối số truyền vào là GPIO đang
		//được sử dụng, chân GPIO có chức năng AF và vị trí chân GPIO sử
		//dụng với chức năng I2C ở Alternate Function nào.

		GPIO_PinAFConfig(I2C_MASTER_PORT,GPIO_PinSource9,GPIO_AF_I2C1);

		/*I2C*/
		I2C_InitStruct.I2C_ClockSpeed = I2C_SPEED;//Sử dụng tần số trên chân SCL là 400KHz.
		I2C_InitStruct.I2C_Mode = I2C_Mode_I2C; //Chọn chế độ là có thể truyền và nhận dữ liệu.
		I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;//Chu kì xung thấp chia xung cao trên chân SCL là 2.
		I2C_InitStruct.I2C_OwnAddress1 = 0x00; //Địa chỉ của I2C là 0.
		I2C_InitStruct.I2C_Ack = I2C_Ack_Enable; //Cho phép sử dụng bit ACK.
		I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; //Sử dụng 7 bit địa chỉ.

		I2C_Init(I2C_MASTER_INSTANCE,&I2C_InitStruct); // Khoi tao I2C
		I2C_Cmd(I2C_MASTER_INSTANCE,ENABLE); //Sử dụng hàm I2C_Cmd để cho phép I2C hoạt động.
}


/*
 * @func   i2c_start
 * @brief  Send bit Start 
 * @param  None
 * @retval None
 */
void i2c_start(void)
{
	//Chờ đường truyền là không bận.
	while(I2C_GetFlagStatus(I2C_MASTER_INSTANCE,I2C_FLAG_BUSY));

	//Gọi hàm I2C_GenerateSTART để truyền bit start.
	I2C_GenerateSTART(I2C_MASTER_INSTANCE,ENABLE);

	//Chờ truyền xong bit start.
	while(!I2C_CheckEvent(I2C_MASTER_INSTANCE,I2C_EVENT_MASTER_MODE_SELECT));
}

/*
 * @func   i2c_address_direction
 * @brief  Send Address Direction
 * @param  Address and Direction
 * @retval None
 */
void i2c_address_direction(u8_t address, u8_t direction)
{
	//Gọi hàm I2C_Send7bitAddress để truyền địa chỉ.
	I2C_Send7bitAddress(I2C_MASTER_INSTANCE,address,direction);

	//Kiểm tra vi điều khiển muốn truyền hay nhận dữ liệu.
	if (direction == I2C_Direction_Transmitter)
	{
		// cho qua trinh gui xong du lieu
		while (!I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
	}
	else if (direction == I2C_Direction_Receiver)
	{
		// cho qua trinh nhan xong du lieu
		while (!I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
	}
}

/*
 * @func   i2c_transmit
 * @brief  Send Data
 * @param  Data Need Send
 * @retval None
 */
void i2c_transmit(u8_t data)
{
	//Gọi hàm I2C_SendData để truyền dữ liệu.
	I2C_SendData(I2C_MASTER_INSTANCE,data);

	//Chờ quá trình truyền hoàn tất
	while(!I2C_CheckEvent(I2C_MASTER_INSTANCE,I2C_EVENT_MASTER_BYTE_TRANSMITTED));
}

/*
 * @func   i2c_stop
 * @brief  Send bit Stop 
 * @param  None
 * @retval None
 */
void i2c_stop(void)
{
	//Gọi hàm I2C_GenerateSTOP để truyền bit stop.
	I2C_GenerateSTOP(I2C_MASTER_INSTANCE,ENABLE);

	while (I2C_GetFlagStatus(I2C_MASTER_INSTANCE, I2C_FLAG_STOPF));
}

/*
 * @func   i2c_receive_ack
 * @brief  Receive bit Ack
 * @param  Ack bit
 * @retval None
 */
u8_t i2c_receive_ack()
{
	// Bật ACK của dữ liệu đã nhận
	I2C_AcknowledgeConfig(I2C_MASTER_INSTANCE, ENABLE);

	// Có nghĩa là dữ liệu đã được nhận trong thanh ghi dữ liệu I2C
	while (!I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_BYTE_RECEIVED));

	// Đọc và trả về byte dữ liệu từ thanh ghi dữ liệu I2C
	return I2C_ReceiveData(I2C_MASTER_INSTANCE);
}

/*
 * @func   i2c_receive_nack
 * @brief  Receive bit Nack
 * @param  Nack bit
 * @retval None
 */
u8_t i2c_receive_nack()
{
	// Tắt ACK của dữ liệu đã nhận
	I2C_AcknowledgeConfig(I2C_MASTER_INSTANCE, DISABLE);

	// Có nghĩa là dữ liệu đã được nhận trong thanh ghi dữ liệu I2C
	while (!I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_BYTE_RECEIVED));

	// Đọc và trả về byte dữ liệu từ thanh ghi dữ liệu I2C
	return I2C_ReceiveData(I2C_MASTER_INSTANCE);
}


/*
 * @func   temhum_sensor_readregister
 * @brief  Read register value and convert to real temhum value
 * @param  temperature or wValue_Humidity  value
 * @retval None
 */
u8_t temhum_sensor_readregister(u8_t address_temhum, u8_t address_register,u8_t size, u8_t time_delay)
{
	u8_t byValue[size -1]; // khai bao bien luu gia tri cua thanh ghi
	uint16_t wValue_Tem; // bien 16 bit luu gia tri 8 bit MS va 8 bit LS
	i2c_start(); // gui bit start
	i2c_address_direction((address_temhum << 1 ),I2C_Direction_Transmitter); // Gui dia chi cua cam bien
	i2c_transmit(address_register); // Gui dia chi cua thanh ghi can lay gia tri
	delay_ms(time_delay); // cho cho qua trinh cap nhat tu thanh ghi
	i2c_stop(); // gui bit stop
	i2c_start();// gui bit restart
	i2c_address_direction((address_temhum << 1 | 1),I2C_Direction_Receiver);// Gui yeu cau can nhan du lieu

	for(int i = 0;i < size; i++)
	{
		if(i < (size-1))
		{
			byValue[i] = i2c_receive_ack();
		}
		else 
		{
			byValue[i] = i2c_receive_nack();
		}
	}
	
	i2c_stop(); // Gui bit stop ket thuc qua trinh truyen nhan du lieu
	wValue_Tem = (uint16_t)byValue[0] <<8 | (uint16_t)byValue[1]; // Dich chuyen va luu gia tri vao bien 16 bit
	if(address_register == VALUE_HMM_REG) // Truong hop muon lay gia tri nhiet do
	{
		g_byValueRegister = (u8_t)(175.72*wValue_Tem/65536 - 46.85); // Cong thuc tinh gia tri nhiet do che do no hold trong datasheet
	}
	if(address_register == VALUE_HMM_REG) // Truong hop lay gia tri cua do am
	{
		g_byValueRegister = (u8_t)(125*wValue_Tem/65536 - 6); // Cong thuc tinh gia tri do am
	}
	if(g_byValueRegister >= 99) // ep gia tri khong duoc lon hon 99 vi do am khong khi binh thuong khong the lon hon 99%
	{
		g_byValueRegister = 99;
	}
	return g_byValueRegister; // tra ve gia tri can do
}

/*
 * @func   Value_Temp_sensor_get_wValue_Tem_value
 * @brief  get sensor temhum
 * @param  Nack bit
 * @retval None
 */
u8_t Value_Temp_sensor_get_wValue_Tem_value(void)
{
	u8_t wValue_Tem = 0;
	wValue_Tem =  temhum_sensor_readregister(SERIAL_ADR,VALUE_HMM_REG,2,1);
	return wValue_Tem ;
}

/*
 * @func   Value_Temp_sensor_get_wValue_Tem_value
 * @brief  get sensor temhum
 * @param  Nack bit
 * @retval None
 */
u8_t Value_Humi_sensor_get_wValue_Tem_value (void)
{
	u8_t wValue_Humi = 0;
	wValue_Humi =  temhum_sensor_readregister(SERIAL_ADR,VALUE_HMM_REG,2,1);
	return wValue_Humi;
}


void process_get_value_sensor(void)
{
	g_dwTimeCurretMeasureTemHum = GetMilSecTick(); // Thoi gian hien tai de tinh thoi gian cho moi lan lay mau gia tri do
	if(g_dwTimeCurretMeasureTemHum >= g_dwTimeInitialMeasureTemHum) // neu bo dem thoi gian chua bi tran
	{
		g_dwTimeTotalMeasureTemHum += g_dwTimeCurretMeasureTemHum - g_dwTimeInitialMeasureTemHum;
	}
	else // Neu bo dem thoi gian bi tran
	{
		g_dwTimeTotalMeasureTemHum += 0xFFFFFFFFU - g_dwTimeCurretMeasureTemHum + g_dwTimeInitialMeasureTemHum;
	}

	if(g_dwTimeTotalMeasureTemHum >= CYCLE_UPDATE_DATA) //
	{
		g_dwTimeTotalMeasureTemHum = 0; // Dat lai thoi gian tong de do lai lan sau
		g_bywValue_Temerature_Value = (u8_t)Value_Temp_sensor_get_wValue_Tem_value(); // Lay gia tri cua nhiet di
		g_bywValue_Temerature_Value = KalmanFilter_updateEstimate_wValue_Tem(g_bywValue_Temerature_Value); // Xu ly qua bo loc kanmal

		g_bywValue_Humidity_Value = (u8_t)Value_Humi_sensor_get_wValue_Tem_value(); // Lay gia tri cua do am
		g_bywValue_Humidity_Value = KalmanFilter_updateEstimate_wValue_Humi(g_bywValue_Humidity_Value); // Xu ly qua bo loc kanmal
		g_byCountTimesUpdatewValue_TemHum++; // Bien dem xem can bao nhieu lan do de hien thi len LCD : trong day lay la 10
		if(g_byCountTimesUpdatewValue_TemHum >= TIME_UPDATE_TEMHUM)
		{
			g_byCountTimesUpdatewValue_TemHum = 0;// Dat lai bien dem
			memset(g_ibTemString,0,sizeof(g_ibTemString));
			sprintf(g_ibTemString,"wValue_Tem = %d oC",g_bywValue_Temerature_Value);// Ep kieu de hien thi LCD
			ucg_DrawString(&ucg,0,32,0,g_ibTemString); // Dat lai Dong va toa do can hien thi
			memset(g_ibwValue_HumiString,0,sizeof(g_ibwValue_HumiString));
			sprintf(g_ibwValue_HumiString,"wValue_Humi = %d %%",g_bywValue_Humidity_Value); // ep kieu de hien thi LCD
			ucg_DrawString(&ucg,0,52,0,g_ibwValue_HumiString);// Hien thi len LCD
		}
	}
	g_dwTimeInitialMeasureTemHum = g_dwTimeCurretMeasureTemHum; // Dat thoi gian lai

}



void delay_ms(u32_t milisecond)
{
	for(u32_t i= 0;i<milisecond;i++)
	{
		for(u32_t j=0;j<5000;j++);
	}
}


void KalmanFilterInit_wValue_Tem(float_t mea_e, float_t est_e, float_t q)
{
  g_dw_err_measure_wValue_Temerature = mea_e;
  g_dw_err_estimate_wValue_Temerature = est_e;
  g_dw_error_number_wValue_Tem = q;
}



void KalmanFilterInit_wValue_Humi(float_t mea_e, float_t est_e, float_t q)
{
  g_dw_err_measure_wValue_Humidity = mea_e;
  g_dw_err_estimate_wValue_Humidity = est_e;
  g_dw_error_number_wValue_Humidity = q;
}


float_t KalmanFilter_updateEstimate_wValue_Tem(float_t mea)
{
  g_dw_kalman_gain_wValue_Tem_wValue_Temerature = g_dw_err_estimate_wValue_Temerature/(g_dw_err_estimate_wValue_Temerature + g_dw_err_measure_wValue_Temerature);
  g_dw_current_estimate_wValue_Temerature = g_dw_last_estimate_wValue_Temerature + g_dw_kalman_gain_wValue_Tem_wValue_Temerature * (mea - g_dw_last_estimate_wValue_Temerature);
  g_dw_err_estimate_wValue_Temerature =  (1.0 - g_dw_kalman_gain_wValue_Tem_wValue_Temerature)*g_dw_err_estimate_wValue_Temerature + fabs(g_dw_last_estimate_wValue_Temerature-g_dw_current_estimate_wValue_Temerature)*g_dw_error_number_wValue_Tem;
  g_dw_last_estimate_wValue_Temerature=g_dw_current_estimate_wValue_Temerature;

  return g_dw_current_estimate_wValue_Temerature;
}



float_t KalmanFilter_updateEstimate_wValue_Humi(float_t mea)
{
  g_dw_kalman_gain_wValue_Tem_wValue_Humidity = g_dw_err_estimate_wValue_Humidity/(g_dw_err_estimate_wValue_Humidity + g_dw_err_measure_wValue_Humidity);
  g_dw_current_estimate_wValue_Humidity = g_dw_last_estimate_wValue_Humidity + g_dw_kalman_gain_wValue_Tem_wValue_Humidity * (mea - g_dw_last_estimate_wValue_Humidity);
  g_dw_err_estimate_wValue_Humidity =  (1.0 - g_dw_kalman_gain_wValue_Tem_wValue_Humidity)*g_dw_err_estimate_wValue_Humidity + fabs(g_dw_last_estimate_wValue_Humidity-g_dw_current_estimate_wValue_Humidity)*g_dw_error_number_wValue_Humidity;
  g_dw_last_estimate_wValue_Humidity=g_dw_current_estimate_wValue_Humidity;

  return g_dw_current_estimate_wValue_Humidity;
}

